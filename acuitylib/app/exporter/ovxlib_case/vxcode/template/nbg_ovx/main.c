/****************************************************************************
*   Generated by ACUITY #ACUITY_VERSION#
*
*   Neural Network application project entry file
****************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <errno.h>
#include <math.h>
#include <assert.h>
#include <VX/vx_khr_cnn.h>
#include <VX/viv_nn_compatibility.h>
#include <VX/vx_khr_import_kernel.h>
#ifdef __linux__
#include <time.h>
#elif defined(_WIN32)
#include <windows.h>
#endif
#include "vnn_utils.h"

#define _CHECK_OBJ(ptr, label) \
do \
{ \
    if ((ptr) == NULL) \
    { \
        printf("create fail %d\n", __LINE__); \
        goto label; \
    } \
} while(0)

#define _CHECK_STATUS(status, label) \
do \
{ \
    if (status != VX_SUCCESS) \
    { \
        printf("process fail %d\n", __LINE__); \
        goto label; \
    } \
} while(0)

#define BILLION                                 1000000000
static uint64_t get_perf_count()
{
#if defined(__linux__) || defined(__ANDROID__) || defined(__QNX__) || defined(__CYGWIN__)
    struct timespec ts;

    clock_gettime(CLOCK_MONOTONIC, &ts);

    return (uint64_t)((uint64_t)ts.tv_nsec + (uint64_t)ts.tv_sec * BILLION);
#elif defined(_WIN32) || defined(UNDER_CE)
    LARGE_INTEGER freq;
    LARGE_INTEGER ln;

    QueryPerformanceFrequency(&freq);
    QueryPerformanceCounter(&ln);

    return (uint64_t)(ln.QuadPart * BILLION / freq.QuadPart);
#endif
}

/*-------------------------------------------
                  Main Functions
-------------------------------------------*/

int main
    (
    int argc,
    char **argv
    )
{
    vx_context  context = NULL;
    vx_graph    graph = NULL;
    vx_kernel   kernel = NULL;
    vx_node     node = NULL;
    vx_status   status = VX_FAILURE;

#VX_TENSOR_DEFINITION#
    vx_tensor_create_params_t ts_params;
    vx_uint32  sizes[6];
#VX_SCALES#
    uint64_t tmsStart, tmsEnd;
    float msAvg, usAvg;
    vx_int32 i,loop = 1; /* default loop time is 1 */
    char *loop_s = getenv("VNN_LOOP_TIME");
    if(loop_s)
    {
        loop = atoi(loop_s);
    }
    if(argc < #VX_ARG_NUM#)
    {
        printf("Usage: %s nb file, input files...\n", argv[0]);
        return -1;
    }

    context = vxCreateContext();
    _CHECK_OBJ(context, exit);

    graph = vxCreateGraph(context);
    _CHECK_OBJ(graph, exit);

    kernel = vxImportKernelFromURL(context, VX_VIVANTE_IMPORT_KERNEL_FROM_FILE, argv[1]);
    status = vxGetStatus((vx_reference)kernel);
    _CHECK_STATUS(status, exit);

    node = vxCreateGenericNode(graph, kernel);
    status = vxGetStatus((vx_reference)node);
    _CHECK_STATUS(status, exit);

#VX_TENSOR_PARAMS#
#VX_SET_PARAMS#

    status = vxVerifyGraph(graph);
    _CHECK_STATUS(status, exit);

#VX_LOAD_INPUT#
    printf("Start run graph [%d] times...\n", loop);
    tmsStart = get_perf_count();
    for(i = 0; i < loop; i++)
    {
        status = vxProcessGraph(graph);
        _CHECK_STATUS(status, exit);
    }
    tmsEnd = get_perf_count();
    msAvg = (tmsEnd - tmsStart)/1000000/loop;
    usAvg = (tmsEnd - tmsStart)/1000/loop;
    printf("Loop:%d,Average: %.2f ms or %.2f us\n",loop, msAvg,usAvg);

#VX_SHOW_AND_SAVE_OUTPUT#

exit:
#VX_RELEASE_INPUT_AND_OUTPUT#
    if (kernel != NULL)
        vxReleaseKernel(&kernel);
    if (node != NULL)
        vxReleaseNode(&node);
    if (graph != NULL)
        vxReleaseGraph(&graph);
    if (context != NULL)
        vxReleaseContext(&context);
    return 0;
}
