/****************************************************************************
*   Generated by ACUITY #ACUITY_VERSION#
*
*   Neural Network Vnn Utils Source file
****************************************************************************/

#include "vnn_utils.h"

#ifdef WIN32
static vx_float32 round(vx_float32 x)
{
#if defined(_M_X64)
    return (vx_float32) _copysignf(floorf(fabsf(x) + 0.5f), x);
#else
    return (vx_float32) _copysign(floorf(fabsf(x) + 0.5f), x);
#endif
}
#endif

vx_uint32 vnn_GetTypeSize(vx_enum format)
{
    switch(format)
    {
        case VX_TYPE_INT8:
        case VX_TYPE_UINT8:
            return 1;
        case VX_TYPE_INT16:
        case VX_TYPE_UINT16:
            return 2;
        case VX_TYPE_INT32:
        case VX_TYPE_UINT32:
            return 4;
        case VX_TYPE_INT64:
        case VX_TYPE_UINT64:
            return 8;
        case VX_TYPE_FLOAT32:
            return 4;
        case VX_TYPE_FLOAT64:
            return 8;
        case VX_TYPE_ENUM:
            return 4;
        case VX_TYPE_FLOAT16:
            return 2;
    }
    return 4;
}

vx_int8 vnn_Fp32toInt8(vx_float32 val, vx_int8 fixedPointPos)
{
    vx_int8 result = 0;

    if (fixedPointPos > 0)
    {
        vx_int32 data = (vx_int32) round(val * (vx_float32)(1 << fixedPointPos));
        result = (vx_int8)((data > 127) ? 127 : (data < -128) ? -128 : data);

    }
    else
    {
        vx_int32 data = (vx_int32) round(val * (1.0f / (vx_float32)(1 << -fixedPointPos)));
        result = (vx_int8)((data > 127) ? 127 : (data < -128) ? -128 : data);
    }

    return result;
}

vx_float32 vnn_Int8toFp32(vx_int8 val, vx_int8 fixedPointPos)
{
    vx_float32 result = 0.0f;

    if (fixedPointPos > 0)
    {
        result = (vx_float32)val * (1.0f / ((vx_uint32) (1 << fixedPointPos)));
    }
    else
    {
        result = (vx_float32)val * ((vx_float32) (1 << -fixedPointPos));
    }

    return result;
}

vx_uint8 vnn_Fp32toUint8(vx_float32 val, vx_int32 zeroPoint, vx_float32 scale)
{
    vx_uint8 result = 0;
    vx_int32 data;

    data = (vx_int32) round((val / scale + (vx_uint8)zeroPoint));

    if (data > 255)
        data = 255;

    if (data < 0)
        data = 0;

    result = (vx_uint8)(data);

    return result;
}
vx_float32 vnn_Uint8toFp32(vx_uint8 val, vx_int32 zeroPoint, vx_float32 scale)
{
    vx_float32 result = 0.0f;

    result = (val - (vx_uint8)zeroPoint) * scale;
    return result;
}

vx_float32 vnn_Int16toFp32(vx_int16 val, vx_int8 fixedPointPos)
{
    vx_float32 result = 0.0f;
    vx_float32 value = val;
    if (fixedPointPos > 0)
    {
        result = value * (1.0f / ((vx_uint32) (1 << fixedPointPos)));
    }
    else
    {
        result = value * ((vx_float32) (1 << -fixedPointPos));
    }

    return result;

}
vx_int16 vnn_Fp32toInt16(vx_float32 val, vx_int8 fixedPointPos)
{
    vx_int16 result = 0;

    if (fixedPointPos > 0)
    {
        vx_int32 data = (vx_int32) round(val * (vx_float32)(1 << fixedPointPos));
        result = (vx_int16)((data > 32767) ? 32767 : (data < -32768) ? -32768 : data);

    }
    else
    {
        vx_int32 data = (vx_int32) round(val * (1.0f / (vx_float32)(1 << -fixedPointPos)));
        result = (vx_int16)((data > 32767) ? 32767 : (data < -32768) ? -32768 : data);
    }

    return result;
}


vx_int16 vnn_Fp32toFp16(vx_float32 val)
{
#define F16_EXPONENT_BITS 0x1F
#define F16_EXPONENT_BIAS 15

#define F16_EXPONENT_SHIFT 10
#define F16_MANTISSA_BITS ((1 << F16_EXPONENT_SHIFT) - 1)
#define F16_MANTISSA_SHIFT (23 - F16_EXPONENT_SHIFT)
#define F16_MAX_EXPONENT (F16_EXPONENT_BITS << F16_EXPONENT_SHIFT)

    vx_uint32 f32 = (*(vx_uint32 *) &val);
    vx_int16 f16 = 0;
    /* Decode IEEE 754 little-endian 32-bit floating-point value */
    int sign = (f32 >> 16) & 0x8000;
    /* Map exponent to the range [-127,128] */
    int exponent = ((f32 >> 23) & 0xff) - 127;
    int mantissa = f32 & 0x007fffff;
    if (exponent == 128)
    { /* Infinity or NaN */
        if (mantissa)
        {
            /* Flush NaN to 0. */
            f16 = (vx_int16)sign;
        }
        else
        {
            /* Clamp to HALF_MAX/HALF_MIN. */
            f16 = (vx_int16)(sign | ((F16_EXPONENT_BITS - 1) << F16_EXPONENT_SHIFT) | F16_MANTISSA_BITS);
        }
    }
    else if (exponent > 15)
    { /* Overflow - clamp to HALF_MAX/HALF_MIN. */
        f16 = (vx_int16)(sign | ((F16_EXPONENT_BITS - 1) << F16_EXPONENT_SHIFT) | F16_MANTISSA_BITS);
    }
    else if (exponent > -15)
    { /* Representable value */
        /* RTNE */
        int roundingBit = (mantissa >> (F16_MANTISSA_SHIFT - 1)) & 0x1;
        int stickyBits = mantissa & 0xFFF;
        exponent += F16_EXPONENT_BIAS;
        mantissa >>= F16_MANTISSA_SHIFT;
        if (roundingBit)
        {
            if (stickyBits || (mantissa & 0x1))
            {
                mantissa++;
                if (mantissa > F16_MANTISSA_BITS)
                {
                    exponent++;
                    if (exponent > 30)
                    {
                        /* Clamp to HALF_MAX/HALF_MIN. */
                        exponent--;
                        mantissa--;
                    }
                    else
                    {
                        mantissa &= F16_MANTISSA_BITS;
                    }
                }
            }
        }
        f16 = (vx_int16)(sign | exponent << F16_EXPONENT_SHIFT | mantissa);
    }
    else
    {
        f16 = (vx_int16)sign;
    }
    return f16;
}

vx_float32 vnn_Fp16toFp32(const vx_uint16 in)
{
    vx_uint32 t1;
    vx_uint32 t2;
    vx_uint32 t3;
    vx_float32 out;

    t1 = in & 0x7fff;                       // Non-sign bits
    t2 = in & 0x8000;                       // Sign bit
    t3 = in & 0x7c00;                       // Exponent
    t1 <<= 13;                              // Align mantissa on MSB
    t2 <<= 16;                              // Shift sign bit into position
    t1 += 0x38000000;                       // Adjust bias
    t1 = (t3 == 0 ? 0 : t1);                // Denormals-as-zero
    t1 |= t2;                               // Re-insert sign bit
    *((uint32_t*)&out) = t1;
    return out;
}

vx_uint32 vnn_GetTensorSize(vx_tensor tensor)
{
    vx_uint32 size[6];
    vx_uint32 num=1,num_of_dim=0;
    vx_uint32 i = 0;
    vxQueryTensor(tensor, VX_TENSOR_NUM_OF_DIMS, &num_of_dim, sizeof(num_of_dim));
    vxQueryTensor(tensor, VX_TENSOR_DIMS, size, sizeof(size));
    for(i = 0; i < num_of_dim;i++)
        num = num*size[i];
    return num;
}
vx_uint32 vnn_GetTensorBufferSize(vx_tensor tensor)
{
    vx_uint32 size[6];
    vx_uint32 num=1,num_of_dim=0;
    vx_enum data_format;
    vx_uint32 i = 0;
    vxQueryTensor(tensor, VX_TENSOR_NUM_OF_DIMS, &num_of_dim, sizeof(num_of_dim));
    vxQueryTensor(tensor, VX_TENSOR_DIMS, size, sizeof(size));
    vxQueryTensor(tensor, VX_TENSOR_DATA_TYPE, &data_format, sizeof(data_format));
    num = vnn_GetTypeSize(data_format);
    for(i = 0; i < num_of_dim;i++)
        num = num*size[i];
    return num;
}
vx_status  vnn_CopyTensorToData(vx_tensor tensor,void **buf)
{
    vx_uint32 size[6];
    vx_uint32 stride_size[6];
    vx_uint32 num=1,num_of_dim=0;
    vx_tensor_addressing user_addr = NULL;
    vx_status status = VX_SUCCESS;
    vx_uint32 i = 0;
    vx_enum data_format;
    vx_uint32 data_size = 0;
    vx_context context = vxGetContext((vx_reference)tensor);
    status |= vxQueryTensor(tensor, VX_TENSOR_NUM_OF_DIMS, &num_of_dim, sizeof(num_of_dim));
    status |=vxQueryTensor(tensor, VX_TENSOR_DIMS, size, sizeof(size));
    status |=vxQueryTensor(tensor, VX_TENSOR_DATA_TYPE, &data_format, sizeof(data_format));

    stride_size[0] = vnn_GetTypeSize(data_format);
    for(i = 0; i < num_of_dim;i++)
        num = num*size[i];
    for ( i=1; i<num_of_dim; i++)
        stride_size[i] = stride_size[i-1] * size[i-1];

    data_size = num*stride_size[0];
    if(*buf == NULL)
        *buf = (void*)malloc(data_size);
    user_addr = vxCreateTensorAddressing(
                             context,
                             size,
                             stride_size,
                             num_of_dim
                             );
    status |= vxCopyTensorPatch(
                tensor,
                NULL,
                user_addr,
                *buf,
                VX_READ_ONLY,
                0
                );
    status |= vxReleaseTensorAddressing(&user_addr);
    return status;
}
vx_status  vnn_CopyTensorToFloat32Data(vx_tensor tensor,vx_float32 **buf)
{
    vx_status status = VX_SUCCESS;
    vx_uint32 num, i = 0;
    vx_enum data_format,quant_format;
    void *data = NULL;

    status |=vxQueryTensor(tensor, VX_TENSOR_DATA_TYPE, &data_format, sizeof(data_format));
    status |=vxQueryTensor(tensor, VX_TENSOR_QUANT_FORMAT, &quant_format, sizeof(data_format));
    num = vnn_GetTensorSize(tensor);
    if(*buf == NULL)
        *buf = (vx_float32*)malloc(num * sizeof(vx_float32));
    status |= vnn_CopyTensorToData(tensor,&data);

    if(quant_format == VX_QUANT_DYNAMIC_FIXED_POINT && data_format == VX_TYPE_INT8)
    {
        vx_int8 fl=0;
        status |=vxQueryTensor(tensor, VX_TENSOR_FIXED_POINT_POSITION, &fl, sizeof(fl));
        if(data_format == VX_TYPE_INT8)
        {
            for(i = 0;i < num; i++)
                (*buf)[i]= vnn_Int8toFp32( ((vx_int8*)data)[i],fl);
        }
    }
    else if(quant_format == VX_QUANT_DYNAMIC_FIXED_POINT && data_format == VX_TYPE_INT16)
    {
        vx_int8 fl=0;
        status |=vxQueryTensor(tensor, VX_TENSOR_FIXED_POINT_POSITION, &fl, sizeof(fl));
        for(i = 0;i < num; i++)
             (*buf)[i]= vnn_Int16toFp32( ((vx_int16*)data)[i],fl);
    }
    else if(quant_format == VX_QUANT_AFFINE_SCALE &&  data_format == VX_TYPE_UINT8)
    {
        vx_int32 zp=0;
        vx_float32 scale;
        status |=vxQueryTensor(tensor, VX_TENSOR_ZERO_POINT, &zp, sizeof(zp));
        status |=vxQueryTensor(tensor, VX_TENSOR_SCALE, &scale, sizeof(scale));
        for(i = 0;i < num; i++)
            (*buf)[i]= vnn_Uint8toFp32( ((vx_uint8*)data)[i],zp,scale);
    }
    else if(data_format == VX_TYPE_FLOAT16)/*VX_QUANT_NONE*/
    {
         for(i = 0;i < num; i++)
             (*buf)[i]= vnn_Fp16toFp32( ((vx_int16*)data)[i]);
    }
    else if(data_format == VX_TYPE_FLOAT32)/*VX_QUANT_NONE*/
    {
         for(i = 0;i < num; i++)
              (*buf)[i] = ((vx_float32*)data)[i];
    }
    else
    {
        printf("can't support format!\n");
        status = VX_FAILURE;
    }
    if(data)
        free(data);
    return status;
}

vx_status  vnn_CopyDataToTensor(vx_tensor tensor,void *buf)
{
    vx_uint32 size[6];
    vx_uint32 stride_size[6];
    vx_uint32 num_of_dim=0;
    vx_tensor_addressing user_addr = NULL;
    vx_status status = VX_SUCCESS;
    vx_uint32 i = 0;
    vx_enum data_format;
    vx_context context = vxGetContext((vx_reference)tensor);

    status |= vxQueryTensor(tensor, VX_TENSOR_NUM_OF_DIMS, &num_of_dim, sizeof(num_of_dim));
    status |=vxQueryTensor(tensor, VX_TENSOR_DIMS, size, sizeof(size));
    status |=vxQueryTensor(tensor, VX_TENSOR_DATA_TYPE, &data_format, sizeof(data_format));

    stride_size[0] = vnn_GetTypeSize(data_format);
    for ( i=1; i<num_of_dim; i++)
        stride_size[i] = stride_size[i-1] * size[i-1];

    user_addr = vxCreateTensorAddressing(
                             context,
                             size,
                             stride_size,
                             num_of_dim
                             );
    status |= vxCopyTensorPatch(
                tensor,
                NULL,
                user_addr,
                buf,
                VX_WRITE_ONLY,
                0
                );
    status |= vxReleaseTensorAddressing(&user_addr);
    return status;
}
vx_status  vnn_CopyFloat32DataToTensor(vx_tensor tensor,vx_float32 *buf)
{
    vx_uint32 num=1;
    vx_status status = VX_SUCCESS;
    vx_uint32 i = 0;
    vx_enum data_format,quant_format;
    void *data = NULL;

    status |=vxQueryTensor(tensor, VX_TENSOR_DATA_TYPE, &data_format, sizeof(data_format));
    status |=vxQueryTensor(tensor, VX_TENSOR_QUANT_FORMAT, &quant_format, sizeof(data_format));
    num = vnn_GetTensorSize(tensor);
    data = (void*)malloc(vnn_GetTensorBufferSize(tensor));

    if(quant_format == VX_QUANT_DYNAMIC_FIXED_POINT && data_format == VX_TYPE_INT8)
    {
        vx_int8 fl=0;
        status |=vxQueryTensor(tensor, VX_TENSOR_FIXED_POINT_POSITION, &fl, sizeof(fl));
        if(data_format == VX_TYPE_INT8)
        {
            for(i = 0;i < num; i++)
                ((vx_int8*)data)[i] = vnn_Fp32toInt8(buf[i],fl);
        }
    }
    else if(quant_format == VX_QUANT_DYNAMIC_FIXED_POINT && data_format == VX_TYPE_INT16)
    {
        vx_int8 fl=0;
        status |=vxQueryTensor(tensor, VX_TENSOR_FIXED_POINT_POSITION, &fl, sizeof(fl));
        for(i = 0;i < num; i++)
             ((vx_int16*)data)[i] = vnn_Fp32toInt16(buf[i],fl);
    }
    else if(quant_format == VX_QUANT_AFFINE_SCALE &&  data_format == VX_TYPE_UINT8)
    {
        vx_int32 zp=0;
        vx_float32 scale;
        status |=vxQueryTensor(tensor, VX_TENSOR_ZERO_POINT, &zp, sizeof(zp));
        status |=vxQueryTensor(tensor, VX_TENSOR_SCALE, &scale, sizeof(scale));
        for(i = 0;i < num; i++)
            ((vx_uint8*)data)[i] = vnn_Fp32toUint8(buf[i],zp,scale);
    }
    else if(data_format == VX_TYPE_FLOAT16)/*VX_QUANT_NONE*/
    {
         for(i = 0;i < num; i++)
             ((vx_int16*)data)[i] = vnn_Fp32toFp16(buf[i]);
    }
    else if(data_format == VX_TYPE_FLOAT32)/*VX_QUANT_NONE*/
    {
         for(i = 0;i < num; i++)
              ((vx_float32*)data)[i] = buf[i];
    }
    else
    {
        printf("can't support format!\n");
        status = VX_FAILURE;
    }
    status |= vnn_CopyDataToTensor(tensor,data);
    if(data)
        free(data);
    return status;
}


static vx_int32 get_file_type(const char *file_name)
{
    const char *ptr;
    char sep = '.';
    uint32_t pos,n;
    char buff[32] = {0};

    ptr = strrchr(file_name, sep);
    pos = ptr - file_name;
    n = strlen(file_name) - (pos + 1);
    strncpy(buff, file_name+(pos+1), n);

    if(strcmp(buff, "tensor") == 0
        || strcmp(buff, "txt") == 0)
    {
        return 0;
    }
    else if(strcmp(buff, "bin") == 0
        || strcmp(buff, "dat") == 0)
    {
        return 1;
    }
    else
    {
       return -1;
    }
}

vx_status vnn_LoadTensorFromFile(vx_tensor tensor,char *filename)
{
    vx_status status = VX_SUCCESS;
    vx_int32 i=0;
    vx_int32 ext = get_file_type(filename);

    if(ext == 0) /*tensor*/
    {
        vx_int32 num = vnn_GetTensorSize(tensor);
        vx_float32 *buf = (vx_float32*)malloc(num*sizeof(vx_float32));
        FILE *fp = fopen(filename,"r");
        if(fp)
        {
            for(i = 0;i < num;i++)
            {
                vx_int32 ret = fscanf(fp,"%f",&buf[i]);
                if(ret <=0 )
                {
                    printf("There is no enough data!\n");
                    status = VX_FAILURE;
                    break;
                }
            }
            status |= vnn_CopyFloat32DataToTensor(tensor,buf);
        }
        else
        {
             printf("can't open file %s\n",filename);
             status |= VX_FAILURE;
        }

        if(buf)
            free(buf);
        if(fp)
            fclose(fp);
    }
    else if(ext == 1) /*dat or bin*/
    {
        vx_int32 size = vnn_GetTensorBufferSize(tensor);
        void *buf = (void*)malloc(size);
        FILE  *fp = fopen(filename,"rb");
        if(fp)
        {
            vx_int32 ret = fread(buf,1,size,fp);
            if(ret < size)
            {
                printf("There is no enough data!\n");
                status = VX_FAILURE;
            }
            status |= vnn_CopyDataToTensor(tensor,buf);
        }
        else
        {
             printf("can't open file %s\n",filename);
             status |= VX_FAILURE;
        }
        if(buf)
            free(buf);
        if(fp)
            fclose(fp);
    }
    else
    {
        printf("not support file type:%s\n",filename);
        status |= VX_FAILURE;
    }
    return status;
}
vx_status  vnn_SaveTensorToFileAsFloat32(vx_tensor tensor,char *filename)
{
    vx_status status = VX_SUCCESS;
    vx_float32 *buf = NULL;
    vx_int32 i=0;
    FILE *fp = NULL;
    vx_uint32 size[6];
    vx_uint32 num=1,num_of_dim=0;
    char str[128] = {'\0'};
    vxQueryTensor(tensor, VX_TENSOR_NUM_OF_DIMS, &num_of_dim, sizeof(num_of_dim));
    vxQueryTensor(tensor, VX_TENSOR_DIMS, size, sizeof(size));
    sprintf(str,"%s",filename);
    for(i = 0; i < num_of_dim;i++)
    {
        num = num*size[i];
        sprintf(str,"%s_%d",str,size[i]);
    }
    sprintf(str,"%s.txt",str);

    fp = fopen(str,"w");
    if(fp)
    {
        status |= vnn_CopyTensorToFloat32Data(tensor,&buf);
        for(i = 0;i<num;i++)
            fprintf(fp,"%f\n",buf[i]);
        fclose(fp);
    }
    else
        status = VX_FAILURE;

    if(buf)
        free(buf);
    return status;
}
vx_status  vnn_SaveTensorToFileAsBinary(vx_tensor tensor,char *filename)
{
    vx_status status = VX_SUCCESS;
    void *buf = NULL;
    vx_int32 i=0;
    FILE *fp = NULL;
    vx_uint32 size[6];
    vx_uint32 num_of_dim=0,num;
    vx_uint32 buf_size = vnn_GetTensorBufferSize(tensor);
    char str[128] = {'\0'};
    vxQueryTensor(tensor, VX_TENSOR_NUM_OF_DIMS, &num_of_dim, sizeof(num_of_dim));

    sprintf(str,"%s",filename);
    for(i = 0; i < num_of_dim;i++)
    {
        num = num*size[i];
        sprintf(str,"%s_%d",str,size[i]);
    }
    sprintf(str,"%s.dat",str);
    fp = fopen(str,"wb");
    if(fp)
    {
        status |= vnn_CopyTensorToData(tensor,&buf);
        fwrite(buf,1,buf_size,fp);
        fclose(fp);
    }
    else
        status = VX_FAILURE;

    if(buf)
        free(buf);
    return status;
}

static vx_bool get_top
    (
    float *pfProb,
    float *pfMaxProb,
    uint32_t *pMaxClass,
    uint32_t outputCount,
    uint32_t topNum
    )
{
    uint32_t i, j;

    #define MAX_TOP_NUM 20
    if (topNum > MAX_TOP_NUM) return vx_false_e;

    memset(pfMaxProb, 0, sizeof(float) * topNum);
    memset(pMaxClass, 0xff, sizeof(float) * topNum);

    for (j = 0; j < topNum; j++)
    {
        for (i=0; i<outputCount; i++)
        {
            if ((i == *(pMaxClass+0)) || (i == *(pMaxClass+1)) || (i == *(pMaxClass+2)) ||
                (i == *(pMaxClass+3)) || (i == *(pMaxClass+4)))
            {
                continue;
            }

            if (pfProb[i] > *(pfMaxProb+j))
            {
                *(pfMaxProb+j) = pfProb[i];
                *(pMaxClass+j) = i;
            }
        }
    }

    return vx_true_e;
}
vx_status vnn_ShowTensorTop5(vx_tensor tensor)
{
    vx_status status = VX_SUCCESS;
    vx_float32 *buf = NULL;
    vx_int32 num = vnn_GetTensorSize(tensor);
    uint32_t MaxClass[5];
    vx_float32 fMaxProb[5];
    vx_int32 i=0;
    status |= vnn_CopyTensorToFloat32Data(tensor,&buf);
    if (!get_top(buf, fMaxProb, MaxClass, num, 5))
    {
        printf("Fail to show result.\n");
        status |= VX_SUCCESS;
        goto final;
    }

    printf(" --- Top5 ---\n");
    for(i=0; i<5; i++)
    {
        printf("%3d: %8.6f\n", MaxClass[i], fMaxProb[i]);
    }
final:
    if(buf)
        free(buf);
    return status;
}
vx_status  vnn_LoadImageFromFile(vx_image image,char *filename)
{
    vx_status status = VX_SUCCESS;
    vx_int32 ext = get_file_type(filename);
    if(ext == 1) /*dat or bin*/
    {
        FILE  *fp = fopen(filename,"rb");
        vx_imagepatch_addressing_t imgInfo = VX_IMAGEPATCH_ADDR_INIT;
        vx_uint8* imgData = 0;
        vx_rectangle_t rect = {0, 0, 0, 0};
        vx_map_id map_id = 0;
        vx_uint32 width=0,height=0;
        vx_df_image format = 0;
        vx_int32 len = 0;
        if(!fp)
        {
            printf("can't open file %s\n",filename);
            return VX_FAILURE;
        }
        status = vxQueryImage( image, VX_IMAGE_FORMAT, &format, sizeof(format) );
        if(format != VX_DF_IMAGE_U8)
        {
            printf("not support image format %d\n",format);
            return VX_FAILURE;
        }
        status = vxQueryImage( image, VX_IMAGE_HEIGHT, &height, sizeof(height) );
        status = vxQueryImage( image, VX_IMAGE_WIDTH, &width, sizeof(width) );
        rect.end_x = width;
        rect.end_y = height;

        vxMapImagePatch(image, &rect, 0, &map_id, &imgInfo, (void**)&imgData, VX_WRITE_ONLY, VX_MEMORY_TYPE_HOST, 0);
        len = fread((void*)imgData,sizeof(vx_uint8),width*height,fp);
        vxUnmapImagePatch(image, map_id);
        if(len < width*height*sizeof(vx_uint8))
            printf("warning:there is no enough data,need %d bytes,actual %d bytes\n",width*height,len);
        fclose(fp);
    }
    else
    {
        printf("not support file type:%s\n",filename);
        status |= VX_FAILURE;
    }
    return status;
}
