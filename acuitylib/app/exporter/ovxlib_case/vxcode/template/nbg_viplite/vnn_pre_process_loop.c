/****************************************************************************
*   Generated by ACUITY #ACUITY_VERSION#
*
*   Neural Network appliction pre-process source file
****************************************************************************/
/*-------------------------------------------
                Includes
-------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "vnn_global.h"
#include "vnn_pre_process.h"

#define _BASETSD_H
/*-------------------------------------------
                  Functions
-------------------------------------------*/
unsigned int load_file(
    const char *name,
    void *dst)
{
    FILE *fp = fopen(name, "rb");
    unsigned int size = 0;
    size_t read_count = 0;

    if (fp != NULL) {
        fseek(fp, 0, SEEK_END);
        size = ftell(fp);

        fseek(fp, 0, SEEK_SET);
        read_count = fread(dst, size, 1, fp);
        if(read_count != 1)
        {
            printf("Read file %s failed.\n", name);
        }

        fclose(fp);
    } else {
        printf("Load file %s failed.\n", name);
    }

    return size;
}

unsigned int get_file_size(
    const char *name)
{
    FILE    *fp = fopen(name, "rb");
    unsigned int size = 0;

    if (fp != NULL) {
        fseek(fp, 0, SEEK_END);
        size = ftell(fp);

        fclose(fp);
    } else {
        printf("Checking file %s failed.\n", name);
    }

    return size;
}

static double copy_sign(
    double number,
    double sign)
{
    double value = fabs(number);
    return (sign > 0) ? value : (-value);
} /* copy_sign() */

static float simple_round(
    float x)
{
    return (float) copy_sign(floorf(fabsf(x) + 0.5f), x);
} /* simple_round() */

static double vsi_rint(
    double x)
{
#define _EPSILON 1e-8
    double decimal;
    double inter;

    decimal = modf((double)x, &inter);

    if( fabs((fabs(decimal) - 0.5f)) < _EPSILON )
    {
        inter += (vip_int32_t)(inter) % 2;
    }
    else
    {
        return simple_round( (float)x );
    }
    return inter;
} /* vsi_rint() */

static  vip_bool_e type_is_integer(
    const vip_enum type)
{
    vip_bool_e ret;
    ret = vip_false_e;
    switch( type )
    {
    case VIP_BUFFER_FORMAT_INT8:
    case VIP_BUFFER_FORMAT_INT16:
    case VIP_BUFFER_FORMAT_INT32:
    case VIP_BUFFER_FORMAT_INT64:
    case VIP_BUFFER_FORMAT_UINT8:
    case VIP_BUFFER_FORMAT_UINT16:
    case VIP_BUFFER_FORMAT_UINT32:
    case VIP_BUFFER_FORMAT_UINT64:
        ret = vip_true_e;
        break;
    default:
        break;
    }
    return ret;
} /* type_is_integer() */

vip_uint32_t type_get_bytes(
    const vip_enum type)
{
    switch( type )
    {
    case VIP_BUFFER_FORMAT_INT8:
    case VIP_BUFFER_FORMAT_UINT8:
        return 1;
    case VIP_BUFFER_FORMAT_INT16:
    case VIP_BUFFER_FORMAT_UINT16:
    case VIP_BUFFER_FORMAT_FP16:
    case VIP_BUFFER_FORMAT_BFP16:
        return 2;
    case VIP_BUFFER_FORMAT_INT32:
    case VIP_BUFFER_FORMAT_UINT32:
    case VIP_BUFFER_FORMAT_FP32:
        return 4;
    case VIP_BUFFER_FORMAT_INT64:
    case VIP_BUFFER_FORMAT_UINT64:
    case VIP_BUFFER_FORMAT_FP64:
        return 8;
    default:
        return 0;
    }
} /* type_get_bytes() */

static vip_bool_e type_is_signed(
    const vip_enum type)
{
    vip_bool_e ret;
    ret = vip_false_e;
    switch( type )
    {
    case VIP_BUFFER_FORMAT_INT8:
    case VIP_BUFFER_FORMAT_INT16:
    case VIP_BUFFER_FORMAT_INT32:
    case VIP_BUFFER_FORMAT_INT64:
    case VIP_BUFFER_FORMAT_FP16:
    case VIP_BUFFER_FORMAT_BFP16:
    case VIP_BUFFER_FORMAT_FP32:
    case VIP_BUFFER_FORMAT_FP64:
        ret = vip_true_e;
        break;
    default:
        break;
    }
    return ret;
} /* type_is_signed() */

static vip_status_e integer_convert(
    const void *    src,
    vip_enum   src_type,
    void *          dest,
    vip_enum   dest_type)
{
    vip_status_e status = VIP_SUCCESS;
    if( type_is_integer( src_type ) && type_is_integer( dest_type ) )
    {
        vip_uint8_t    all_zeros[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
        vip_uint8_t    all_ones[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
        vip_uint32_t   src_sz = type_get_bytes( src_type );
        vip_uint32_t   dest_sz = type_get_bytes( dest_type );
        vip_uint8_t*   buffer = all_zeros;
        if( type_is_signed( src_type ) && (((vip_int8_t *)src)[src_sz - 1] & 0x80) )
        {
            buffer = all_ones;
        }
        memcpy( buffer, src, src_sz );
        memcpy( dest, buffer, dest_sz );
    }
    else
    {
        status = VIP_ERROR_NOT_SUPPORTED;
    }
    return status;
} /* integer_convert() */

static void type_get_range(
    vip_enum type,
    double  * max_range,
    double  * min_range)
{
    vip_int32_t bits;
    double from, to;
    from = 0.0;
    to = 0.0;
    bits = type_get_bytes( type ) * 8;
    if( type_is_integer( type ) )
    {
        if( type_is_signed( type ) )
        {
            from = (double)(-(1L << (bits - 1)));
            to = (double)((1UL << (bits - 1)) - 1);
        }
        else
        {
            from = 0.0;
            to = (double)((1UL << bits) - 1);
        }
    }
    else
    {
        //  TODO: Add float
    }
    if( NULL != max_range )
    {
        *max_range = to;
    }
    if( NULL != min_range )
    {
        *min_range = from;
    }
} /* type_get_range() */

static vip_uint16_t fp32_to_fp16(
    float in)
{
    vip_uint32_t fp32 = *((vip_uint32_t *) &in);
    vip_uint32_t t1 = (fp32 & 0x80000000u) >> 16;  /* sign bit. */
    vip_uint32_t t2 = (fp32 & 0x7F800000u) >> 13;  /* Exponent bits */
    vip_uint32_t t3 = (fp32 & 0x007FE000u) >> 13;  /* Mantissa bits, no rounding */
    vip_uint32_t fp16 = 0u;
    if( t2 >= 0x023c00u )
    {
        fp16 = t1 | 0x7BFF;     /* Don't round to infinity. */
    }
    else if( t2 <= 0x01c000u )
    {
        fp16 = t1;
    }
    else
    {
        t2 -= 0x01c000u;
        fp16 = t1 | t2 | t3;
    }
    return (vip_uint16_t) fp16;
} /* fp32_to_fp16() */

static vip_uint16_t fp32_to_bfp16_rtne(
    float in)
{
    /*
    Convert a float point to bfloat16, with round-nearest-to-even as rounding method.
    */

    vip_uint32_t fp32 = *((unsigned int *) &in);
    vip_uint16_t out;

    vip_uint32_t lsb = (fp32 >> 16) & 1;    /* Least significant bit of resulting bfloat. */
    vip_uint32_t rounding_bias = 0x7fff + lsb;

    if ( VSI_NN_FLOAT32_NAN == in )
    {
        out = 0x7fc0;
    }
    else
    {
        fp32 += rounding_bias;
        out = (vip_uint16_t) (fp32 >> 16);
    }

    return out;
} /* fp32_to_bfp16_rtne */

static vip_int32_t fp32_to_dfp(
    const float in,
    const vip_int8_t    fl,
    const vip_enum type)
{
    vip_int32_t data;
    double max_range;
    double min_range;
    type_get_range( type, &max_range, &min_range );
    if( fl > 0 )
    {
        data = (vip_int32_t)vsi_rint( in * (float)( 1 << fl ) );
    }
    else
    {
        data = (vip_int32_t)vsi_rint( in * ( 1.0f / (float)( 1 << -fl ) ) );
    }
    data = vsi_nn_min( data, (vip_int32_t)max_range );
    data = vsi_nn_max( data, (vip_int32_t)min_range );
    return data;
} /* fp32_to_dfp() */

static vip_int32_t fp32_to_affine(
    const float  in,
    const float  scale,
    const vip_int32_t    zero_point,
    const vip_enum type)
{
    vip_int32_t data;
    double max_range;
    double min_range;
    type_get_range( type, &max_range, &min_range );
    data = (vip_int32_t)(vsi_rint( in / scale ) + zero_point );
    data = vsi_nn_max( (vip_int32_t)min_range, vsi_nn_min( (vip_int32_t)max_range , data ) );
    return data;
} /* fp32_to_affine() */

static vip_status_e float32_to_dtype(
    float   src,
    vip_uint8_t *dst,
    const vip_buffer_create_params_t *dst_params)
{
    switch( dst_params->data_format )
    {
    case VIP_BUFFER_FORMAT_FP32:
        *(float *)dst = src;
        break;
    case VIP_BUFFER_FORMAT_FP16:
        *(vip_int16_t *)dst = fp32_to_fp16( src );
        break;
    case VIP_BUFFER_FORMAT_BFP16:
        *(vip_int16_t *)dst = fp32_to_bfp16_rtne( src );
        break;
    case VIP_BUFFER_FORMAT_INT8:
    case VIP_BUFFER_FORMAT_UINT8:
    case VIP_BUFFER_FORMAT_INT16:
    case VIP_BUFFER_FORMAT_INT32:
        {
            vip_int32_t dst_value = 0;
            switch( dst_params->quant_format )
            {
            case VIP_BUFFER_QUANTIZE_DYNAMIC_FIXED_POINT:
                dst_value = fp32_to_dfp( src, dst_params->quant_data.dfp.fixed_point_pos, dst_params->data_format );
                break;
            case VIP_BUFFER_QUANTIZE_TF_ASYMM:
                dst_value = fp32_to_affine( src, dst_params->quant_data.affine.scale,
                    dst_params->quant_data.affine.zeroPoint, dst_params->data_format );
                break;
            case VIP_BUFFER_QUANTIZE_NONE:
                dst_value = (vip_int32_t)src;
                break;
            default:
                break;
            }
            integer_convert( &dst_value, VIP_BUFFER_FORMAT_INT32, dst, dst_params->data_format );
        }
        break;
    default:
        return VIP_ERROR_NOT_SUPPORTED;
    }
    return VIP_SUCCESS;
}

vip_status_e vnn_Float32ToDtype(
    float   src,
    vip_uint8_t   *dst,
    const vip_buffer_create_params_t *buf_param)
{
    return float32_to_dtype(src, dst, buf_param);
} /* vnn_Float32ToDtype() */

vip_uint32_t vnn_LoadFP32DataFromTextFile(
    const char* fname,
    vip_uint8_t** buffer_ptr,
    const vip_buffer_create_params_t *buf_param)
{
    vip_status_e status = VIP_SUCCESS;
    float fval = 0.0;
    vip_uint32_t i = 0;
    vip_uint8_t* buffer = NULL;
    vip_uint32_t item_ount = 0;
    vip_uint32_t data_size = 0;
    vip_uint32_t stride = type_get_bytes(buf_param->data_format);
    FILE *fp = NULL;

    if(!fname || !buffer_ptr || !buf_param)
    {
        return data_size;
    }

    fp = fopen(fname, "rb");
    if(fp)
    {
        while(!feof(fp) && fscanf( fp, "%f ", &fval ) == 1)
        {
            item_ount++;
        }

        if(item_ount > 0)
        {
            data_size = item_ount * stride;
            buffer = (vip_uint8_t *)malloc(data_size);
            if(buffer)
            {
                int fail_to_read = vip_false_e;

                fseek(fp, 0, SEEK_SET);
                for(i = 0; i < item_ount && !fail_to_read; i++)
                {
                    if(fscanf( fp, "%f ", &fval ) != 1)
                    {
                        printf("Read tensor file fail.\n");
                        printf("Please check file lines or if the file contains illegal characters\n");
                        free(buffer);
                        fail_to_read = vip_true_e;
                        data_size = 0;
                        break;
                    }
                    status = vnn_Float32ToDtype(fval, &buffer[i * stride], buf_param);
                    if (VIP_SUCCESS != status)
                    {
                        printf("Convert data failed.\n");
                        free(buffer);
                        fail_to_read = vip_true_e;
                        data_size = 0;
                        break;
                    }
                }

                if(!fail_to_read)
                {
                    *buffer_ptr = buffer;
                }
            }
            else
            {
                data_size = 0;
                printf("Allocate memory fail!\n");
            }
        }
        else
        {
            printf("No available data found!\n");
        }
        fclose(fp);
    }
    else
    {
        printf("Fail to open %s\n", fname);
    }

    if(!data_size)
    {
        printf("Load data from %s fail!\n", fname);
    }

    return data_size;
}

vip_uint32_t vnn_LoadRawDataFromBinaryFile(
    const char* fname,
    vip_uint8_t** buffer_ptr)
{
    FILE *fp = NULL;
    vip_uint32_t fsize = 0;
    vip_uint32_t read_size = 0;
    vip_uint8_t* buffer = NULL;

    if(!fname || !buffer_ptr)
    {
        return fsize;
    }

    fp = fopen(fname, "rb");
    if(fp)
    {
        fsize = fseek(fp, 0, SEEK_END);
        fsize = ftell(fp);

        buffer = (vip_uint8_t *)malloc(fsize);
        if(buffer)
        {
            fseek(fp, 0, SEEK_SET);
            read_size = fread(buffer, 1, fsize, fp);
            if(read_size == fsize)
            {
                *buffer_ptr = buffer;
            }
            else
            {
                fsize = 0;
                free(buffer);
                buffer = NULL;
            }
        }
        else
        {
            fsize = 0;
            printf("Allocate memory fail!\n");
        }

        if(fp)
        {
            fclose(fp);
        }
    }

    if(!fsize)
    {
        printf("Load data from %s fail!\n", fname);
    }
    return fsize;
}

vip_uint32_t vnn_LoadDataFromFile(
    vip_network_items *network_items,
    const char *fname,
    vip_uint8_t **buf_ptr,
    vip_uint32_t index)
{
    vip_status_e status = VIP_SUCCESS;
    vip_buffer_create_params_t buf_param;
    vip_uint32_t data_size = 0;
    const char *pos = NULL;

    if (((pos = strstr(fname, ".tensor")) && (0 == strcmp(pos, ".tensor")))
        || ((pos = strstr(fname, ".txt")) && (0 == strcmp(pos, ".txt"))))
    {
        memset(&buf_param, 0x00, sizeof(buf_param));
        status = vip_query_input(network_items->network, index,
            VIP_BUFFER_PROP_DATA_FORMAT, &buf_param.data_format);
        _CHECK_STATUS(status, final);
        /* load data from .tensor or .txt file */
        data_size = vnn_LoadFP32DataFromTextFile(fname, buf_ptr, &buf_param);
    }
    else
    {
        data_size = vnn_LoadRawDataFromBinaryFile(fname, buf_ptr);
    }


final:
    return data_size;
}

vip_status_e vnn_CreateInOutBufPrepareNetwork(
    vip_network_items *network_items)
{
    vip_status_e status = VIP_SUCCESS;
    int input_num = 0, input_cnt = 0, i = 0;
    vip_buffer_create_params_t buf_param;

    /* Get network input num */
    status = vip_query_network(network_items->network,
        VIP_NETWORK_PROP_INPUT_COUNT, &input_num);
    _CHECK_STATUS(status, final);
    /* TODO: conn_cnt + input_count may not equal input_num, remove this. */
    input_cnt = network_items->rnn_conn.conn_cnt + network_items->input_count;
    if(input_num != input_cnt) {
        printf("Error: Graph need %d inputs, but get %d inputs!!!\n",
            input_num, input_cnt);
        status = VIP_ERROR_MISSING_INPUT_OUTPUT;
        return status;
    }

    /* Create input buffers */
    network_items->input_buffers = (vip_buffer *)malloc(sizeof(vip_buffer) * input_num);
    for (i = 0; i < input_num; i++) {
        memset(&buf_param, 0, sizeof(buf_param));
        status = vip_query_input(network_items->network, i,
            VIP_BUFFER_PROP_DATA_FORMAT, &buf_param.data_format);
        _CHECK_STATUS(status, final);
        status = vip_query_input(network_items->network, i,
            VIP_BUFFER_PROP_NUM_OF_DIMENSION, &buf_param.num_of_dims);
        _CHECK_STATUS(status, final);
        status = vip_query_input(network_items->network, i,
            VIP_BUFFER_PROP_SIZES_OF_DIMENSION, buf_param.sizes);
        _CHECK_STATUS(status, final);
        status = vip_query_input(network_items->network, i,
            VIP_BUFFER_PROP_QUANT_FORMAT, &buf_param.quant_format);
        _CHECK_STATUS(status, final);
        switch(buf_param.quant_format)
        {
        case VIP_BUFFER_QUANTIZE_DYNAMIC_FIXED_POINT:
             status = vip_query_input(network_items->network, i,
                VIP_BUFFER_PROP_FIXED_POINT_POS, &buf_param.quant_data.dfp.fixed_point_pos);
                 _CHECK_STATUS(status, final);
             break;
        case VIP_BUFFER_QUANTIZE_TF_ASYMM:
             status = vip_query_input(network_items->network, i,
                VIP_BUFFER_PROP_TF_SCALE, &buf_param.quant_data.affine.scale);
             _CHECK_STATUS(status, final);
             status = vip_query_input(network_items->network, i,
                VIP_BUFFER_PROP_TF_ZERO_POINT, &buf_param.quant_data.affine.zeroPoint);
             _CHECK_STATUS(status, final);
             break;
        case VIP_BUFFER_QUANTIZE_NONE:
        default:
             break;
        }

        status = vip_create_buffer(&buf_param, sizeof(buf_param),
            &network_items->input_buffers[i]);
        _CHECK_STATUS(status, final);
    }

    /* Create output buffers */
    status = vip_query_network(network_items->network,
        VIP_NETWORK_PROP_OUTPUT_COUNT, &network_items->output_count);
    network_items->output_buffers = (vip_buffer *)malloc(sizeof(vip_buffer) * network_items->output_count);
    for (i = 0; i < network_items->output_count; i++) {
        memset(&buf_param, 0, sizeof(buf_param));
        status = vip_query_output(network_items->network, i,
            VIP_BUFFER_PROP_DATA_FORMAT, &buf_param.data_format);
        _CHECK_STATUS(status, final);
        status = vip_query_output(network_items->network, i,
            VIP_BUFFER_PROP_NUM_OF_DIMENSION, &buf_param.num_of_dims);
        _CHECK_STATUS(status, final);
        status = vip_query_output(network_items->network, i,
            VIP_BUFFER_PROP_SIZES_OF_DIMENSION, buf_param.sizes);
        _CHECK_STATUS(status, final);
        status = vip_query_output(network_items->network, i,
            VIP_BUFFER_PROP_QUANT_FORMAT, &buf_param.quant_format);
        _CHECK_STATUS(status, final);
        switch(buf_param.quant_format)
        {
        case VIP_BUFFER_QUANTIZE_DYNAMIC_FIXED_POINT:
             status = vip_query_output(network_items->network, i,
                VIP_BUFFER_PROP_FIXED_POINT_POS, &buf_param.quant_data.dfp.fixed_point_pos);
                 _CHECK_STATUS(status, final);
             break;
        case VIP_BUFFER_QUANTIZE_TF_ASYMM:
             status = vip_query_output(network_items->network, i,
                VIP_BUFFER_PROP_TF_SCALE, &buf_param.quant_data.affine.scale);
             _CHECK_STATUS(status, final);
             status = vip_query_output(network_items->network, i,
                VIP_BUFFER_PROP_TF_ZERO_POINT, &buf_param.quant_data.affine.zeroPoint);
             _CHECK_STATUS(status, final);
             break;
        case VIP_BUFFER_QUANTIZE_NONE:
        default:
             break;
        }

        status = vip_create_buffer(&buf_param, sizeof(buf_param),
            &network_items->output_buffers[i]);
        _CHECK_STATUS(status, final);
    }

    /* Prepare network */
    status = vip_prepare_network(network_items->network);
    _CHECK_STATUS(status, final);

final:
    return status;
}

vip_status_e vnn_BuffDataInit(
    void *data,
    vip_uint32_t buf_size,
    const vip_buffer_create_params_t *buf_param,
    float default_value)
{
    vip_status_e status = VIP_SUCCESS;
    vip_uint32_t element_num = 0;
    vip_uint32_t stride = 0, i = 0;
    vip_uint8_t * data_ptr = (vip_uint8_t *)data;

    stride = type_get_bytes(buf_param->data_format);
    element_num = buf_size / stride;
    for (i = 0; i < element_num; i++) {
        status = vnn_Float32ToDtype(default_value, data_ptr + i * stride, buf_param);
        _CHECK_STATUS(status, final);
    }

final:
    return status;
}

vip_status_e vnn_InitRnnConnBufData(
    vip_network_items *network_items)
{
    vip_status_e status = VIP_SUCCESS;
    vip_buffer_create_params_t buf_param;
    vip_int32_t input_num = 0, i = 0;
    vip_uint32_t buff_size = 0;
    void * data;

    /* Initialize the not given inputs */
    status = vip_query_network(network_items->network,
        VIP_NETWORK_PROP_INPUT_COUNT, &input_num);
    _CHECK_STATUS(status, final);
    for ( i = network_items->input_count; i < input_num; i++ ) {
        memset(&buf_param, 0, sizeof(buf_param));
        status = vip_query_output(network_items->network, i,
            VIP_BUFFER_PROP_DATA_FORMAT, &buf_param.data_format);
        _CHECK_STATUS(status, final);
        data = vip_map_buffer(network_items->input_buffers[i]);
        buff_size = vip_get_buffer_size(network_items->input_buffers[i]);
        status = vnn_BuffDataInit(data, buff_size, &buf_param, 0.0f);
        _CHECK_STATUS(status, final);
        /* Set input */
        status = vip_set_input(network_items->network,
            i, network_items->input_buffers[i]);
        _CHECK_STATUS(status, final);
    }

final:
    return status;
}

vip_status_e vnn_SetNetworkInOut(
    vip_network_items *network_items)
{
    vip_status_e status = VIP_SUCCESS;
    vip_int32_t i;

    /* Initialize and set recurrent connection input */
    status = vnn_InitRnnConnBufData( network_items );
    _CHECK_STATUS(status, final);
    /* Set output */
    for (i = 0; i < network_items->output_count; i++) {
        status = vip_set_output(network_items->network,
            i, network_items->output_buffers[i]);
        _CHECK_STATUS(status, final);
    }

final:
    return status;
}
