/****************************************************************************
*   Generated by ACUITY #ACUITY_VERSION#
*   Match ovxlib #OVXLIB_VERSION#
*
*   Neural Network application project entry file
****************************************************************************/
/*-------------------------------------------
                Includes
-------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifdef __linux__
#include <time.h>
#include <inttypes.h>
#elif defined(_WIN32)
#include <windows.h>
#endif

#define _BASETSD_H

#include "vsi_nn_pub.h"

#include "vnn_global.h"
#include "vnn_pre_process.h"
#include "vnn_post_process.h"
#SUB_NETWORK_HEADER#

/*-------------------------------------------
        Macros and Variables
-------------------------------------------*/
#ifdef __linux__
#define VSI_UINT64_SPECIFIER PRIu64
#elif defined(_WIN32)
#define VSI_UINT64_SPECIFIER "I64u"
#endif

#define GRAPH_NUM (#GRAPH_NUM#)

/*-------------------------------------------
                  Functions
-------------------------------------------*/
static void vnn_ReleaseNeuralNetwork
    (
    vsi_nn_graph_t **graph
    )
{
#SUB_NETWORK_RELEASE#
}

static vsi_status vnn_PostProcessNeuralNetwork
    (
    vsi_nn_graph_t *graph
    )
{
    return vnn_PostProcess#NETWORK_NAME#(graph);
}

static vsi_status vnn_VerifyGraph
    (
    vsi_nn_graph_t **graph
    )
{
    vsi_status status = VSI_FAILURE;
    uint32_t i = 0;

    /* Verify graph */
    for(i=0; i<GRAPH_NUM; i++)
    {
        printf("Verify graph[%d]...\n", i);
        status = vsi_nn_VerifyGraph(graph[i]);
        TEST_CHECK_STATUS(status, final);
    }

final:
    return status;
}

static vsi_status vnn_ProcessGraph
    (
    vsi_nn_graph_t **graph
    )
{
    vsi_status status = VSI_FAILURE;
    vsi_nn_tensor_t *max_iteration = NULL;

    max_iteration = vsi_nn_GetTensor(graph[#ITER_GRAPH_ID#], graph[#ITER_GRAPH_ID#]->output.tensors[0]);

#LOOP_PROCESS#

final:
    return status;
}

static vsi_status vnn_PreProcessNeuralNetwork
    (
    vsi_nn_graph_t *graph,
    int argc,
    char **argv
    )
{
    /*
     * argv0:   execute file
     * argv1:   data file
     * argv2~n: inputs n file
     */
    const char **inputs = (const char **)argv + 2;
    uint32_t input_num = argc - 2;

    return vnn_PreProcess#NETWORK_NAME#(graph, inputs, input_num);
}

static vsi_nn_graph_t **vnn_CreateNeuralNetwork
    (
    const char *data_file
    )
{
    vsi_nn_context_t ctx;
    vsi_nn_graph_t **graph = NULL;

    /* Create context */
    ctx = vsi_nn_CreateContext();

    graph = (vsi_nn_graph_t **)malloc(GRAPH_NUM * sizeof(vsi_nn_graph_t *));

#SUB_NETWORK_CREATE#
    return graph;
final:
    vsi_nn_safe_free(graph);
    return NULL;
}

/*-------------------------------------------
                  Main Functions
-------------------------------------------*/
int main
    (
    int argc,
    char **argv
    )
{
    vsi_status status = VSI_FAILURE;
    const char *data_name = NULL;
    vsi_nn_graph_t **graph = NULL;

    if(argc < 3)
    {
        printf("Usage: %s data_file inputs...\n", argv[0]);
        return -1;
    }

    data_name = (const char *)argv[1];

    graph = vnn_CreateNeuralNetwork(data_name);
    TEST_CHECK_PTR(graph, final);

    /* Verify graph */
    status = vnn_VerifyGraph(graph);
    TEST_CHECK_STATUS(status, final);

    /* Pre process the image data */
    status = vnn_PreProcessNeuralNetwork(graph[#PRE_GRAPH_ID#], argc, argv);
    TEST_CHECK_STATUS(status, final);

    /* Process graph */
    status = vnn_ProcessGraph(graph);
    TEST_CHECK_STATUS(status, final);

    /* Post process output data */
    status = vnn_PostProcessNeuralNetwork(graph[#POST_GRAPH_ID#]);
    TEST_CHECK_STATUS(status, final);

final:
    vnn_ReleaseNeuralNetwork(graph);
    vsi_nn_safe_free(graph);
    fflush(stdout);
    fflush(stderr);
    return status;
}
